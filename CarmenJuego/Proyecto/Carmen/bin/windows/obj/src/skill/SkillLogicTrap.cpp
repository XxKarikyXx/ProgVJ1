// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_GlobalGameData
#include <GlobalGameData.h>
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_flixel_FlxBasic
#include <flixel/FlxBasic.h>
#endif
#ifndef INCLUDED_flixel_FlxG
#include <flixel/FlxG.h>
#endif
#ifndef INCLUDED_flixel_FlxObject
#include <flixel/FlxObject.h>
#endif
#ifndef INCLUDED_flixel_FlxSprite
#include <flixel/FlxSprite.h>
#endif
#ifndef INCLUDED_flixel_group_FlxTypedGroup
#include <flixel/group/FlxTypedGroup.h>
#endif
#ifndef INCLUDED_flixel_input_FlxPointer
#include <flixel/input/FlxPointer.h>
#endif
#ifndef INCLUDED_flixel_input_IFlxInputManager
#include <flixel/input/IFlxInputManager.h>
#endif
#ifndef INCLUDED_flixel_input_mouse_FlxMouse
#include <flixel/input/mouse/FlxMouse.h>
#endif
#ifndef INCLUDED_flixel_util_IFlxDestroyable
#include <flixel/util/IFlxDestroyable.h>
#endif
#ifndef INCLUDED_gameObjects_Player1
#include <gameObjects/Player1.h>
#endif
#ifndef INCLUDED_gameObjects_Trap
#include <gameObjects/Trap.h>
#endif
#ifndef INCLUDED_skill_FlxButtonAnimationSkill
#include <skill/FlxButtonAnimationSkill.h>
#endif
#ifndef INCLUDED_skill_ISkillLogic
#include <skill/ISkillLogic.h>
#endif
#ifndef INCLUDED_skill_SkillLogicTrap
#include <skill/SkillLogicTrap.h>
#endif

HX_DEFINE_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_21_new,"skill.SkillLogicTrap","new",0x9804b969,"skill.SkillLogicTrap.new","skill/SkillLogicTrap.hx",21,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_25_preparationSkill,"skill.SkillLogicTrap","preparationSkill",0x0b3da291,"skill.SkillLogicTrap.preparationSkill","skill/SkillLogicTrap.hx",25,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_35_skillExecution,"skill.SkillLogicTrap","skillExecution",0x13c74d5e,"skill.SkillLogicTrap.skillExecution","skill/SkillLogicTrap.hx",35,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_50_skillReset,"skill.SkillLogicTrap","skillReset",0xe08e9095,"skill.SkillLogicTrap.skillReset","skill/SkillLogicTrap.hx",50,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_57_skillUpdateValidation,"skill.SkillLogicTrap","skillUpdateValidation",0xcddb1e9c,"skill.SkillLogicTrap.skillUpdateValidation","skill/SkillLogicTrap.hx",57,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_74_setUINotPossiblePlaceToPutTrapFromSkill2,"skill.SkillLogicTrap","setUINotPossiblePlaceToPutTrapFromSkill2",0x5cae69ca,"skill.SkillLogicTrap.setUINotPossiblePlaceToPutTrapFromSkill2","skill/SkillLogicTrap.hx",74,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_79_setUIPossiblePlaceToPutTrapFromSkill2,"skill.SkillLogicTrap","setUIPossiblePlaceToPutTrapFromSkill2",0x0a5f62f5,"skill.SkillLogicTrap.setUIPossiblePlaceToPutTrapFromSkill2","skill/SkillLogicTrap.hx",79,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_84_setUIPlacedTrapFromSkill2,"skill.SkillLogicTrap","setUIPlacedTrapFromSkill2",0x5ec8e6d4,"skill.SkillLogicTrap.setUIPlacedTrapFromSkill2","skill/SkillLogicTrap.hx",84,0x5b651506)
HX_LOCAL_STACK_FRAME(_hx_pos_8bb4989bc5a1b769_88_skill2ConditionToPutElement,"skill.SkillLogicTrap","skill2ConditionToPutElement",0xfb929c0b,"skill.SkillLogicTrap.skill2ConditionToPutElement","skill/SkillLogicTrap.hx",88,0x5b651506)
namespace skill{

void SkillLogicTrap_obj::__construct(::String aTextDescription){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_21_new)
HXDLIN(  21)		this->vTextDescription = aTextDescription;
            	}

Dynamic SkillLogicTrap_obj::__CreateEmpty() { return new SkillLogicTrap_obj; }

void *SkillLogicTrap_obj::_hx_vtable = 0;

Dynamic SkillLogicTrap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< SkillLogicTrap_obj > _hx_result = new SkillLogicTrap_obj();
	_hx_result->__construct(inArgs[0]);
	return _hx_result;
}

bool SkillLogicTrap_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x2776d10b;
}

static ::skill::ISkillLogic_obj _hx_skill_SkillLogicTrap__hx_skill_ISkillLogic= {
	( void (hx::Object::*)())&::skill::SkillLogicTrap_obj::preparationSkill,
	( bool (hx::Object::*)())&::skill::SkillLogicTrap_obj::skillExecution,
	( void (hx::Object::*)())&::skill::SkillLogicTrap_obj::skillReset,
	( void (hx::Object::*)())&::skill::SkillLogicTrap_obj::skillUpdateValidation,
};

void *SkillLogicTrap_obj::_hx_getInterface(int inHash) {
	switch(inHash) {
		case (int)0xddb348c5: return &_hx_skill_SkillLogicTrap__hx_skill_ISkillLogic;
	}
	#ifdef HXCPP_SCRIPTABLE
	return super::_hx_getInterface(inHash);
	#else
	return 0;
	#endif
}

void SkillLogicTrap_obj::preparationSkill(){
            	HX_GC_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_25_preparationSkill)
HXLINE(  26)		 ::gameObjects::Trap trap =  ::gameObjects::Trap_obj::__alloc( HX_CTX ,::flixel::FlxG_obj::mouse->x,::flixel::FlxG_obj::mouse->y);
HXLINE(  27)		this->vActualTrap = trap;
HXLINE(  28)		 ::gameObjects::Trap _hx_tmp = this->vActualTrap;
HXDLIN(  28)		int _hx_tmp1 = ::flixel::FlxG_obj::mouse->x;
HXDLIN(  28)		Float _hx_tmp2 = (_hx_tmp1 - ((Float)this->vActualTrap->get_width() / (Float)(int)2));
HXDLIN(  28)		int _hx_tmp3 = ::flixel::FlxG_obj::mouse->y;
HXDLIN(  28)		_hx_tmp->setPosition(_hx_tmp2,(_hx_tmp3 - ((Float)this->vActualTrap->get_height() / (Float)(int)2)));
HXLINE(  29)		this->setUINotPossiblePlaceToPutTrapFromSkill2();
HXLINE(  30)		this->vTraps->add(trap).StaticCast<  ::flixel::FlxBasic >();
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,preparationSkill,(void))

bool SkillLogicTrap_obj::skillExecution(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_35_skillExecution)
HXDLIN(  35)		if (this->skill2ConditionToPutElement()) {
HXLINE(  37)			this->setUIPlacedTrapFromSkill2();
HXLINE(  38)			this->vActualTrap->vCanCollide = true;
HXLINE(  39)			this->vActualTrap = null();
HXLINE(  40)			this->vSkillButton->setActivation();
HXLINE(  41)			return true;
            		}
            		else {
HXLINE(  45)			return false;
            		}
HXLINE(  35)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,skillExecution,return )

void SkillLogicTrap_obj::skillReset(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_50_skillReset)
HXLINE(  51)		this->vTraps->remove(this->vActualTrap,true).StaticCast<  ::flixel::FlxBasic >();
HXLINE(  52)		this->vActualTrap->destroy();
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,skillReset,(void))

void SkillLogicTrap_obj::skillUpdateValidation(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_57_skillUpdateValidation)
HXDLIN(  57)		if (hx::IsNotNull( this->vActualTrap )) {
HXLINE(  59)			 ::gameObjects::Trap _hx_tmp = this->vActualTrap;
HXDLIN(  59)			int _hx_tmp1 = ::flixel::FlxG_obj::mouse->x;
HXDLIN(  59)			Float _hx_tmp2 = (_hx_tmp1 - ((Float)this->vActualTrap->get_width() / (Float)(int)2));
HXDLIN(  59)			int _hx_tmp3 = ::flixel::FlxG_obj::mouse->y;
HXDLIN(  59)			_hx_tmp->setPosition(_hx_tmp2,(_hx_tmp3 - ((Float)this->vActualTrap->get_height() / (Float)(int)2)));
HXLINE(  61)			if (this->skill2ConditionToPutElement()) {
HXLINE(  63)				this->setUIPossiblePlaceToPutTrapFromSkill2();
            			}
            			else {
HXLINE(  67)				this->setUINotPossiblePlaceToPutTrapFromSkill2();
            			}
            		}
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,skillUpdateValidation,(void))

void SkillLogicTrap_obj::setUINotPossiblePlaceToPutTrapFromSkill2(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_74_setUINotPossiblePlaceToPutTrapFromSkill2)
HXDLIN(  74)		this->vActualTrap->setColorTransform((int)1,(int)0,(int)0,((Float)0.8),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,setUINotPossiblePlaceToPutTrapFromSkill2,(void))

void SkillLogicTrap_obj::setUIPossiblePlaceToPutTrapFromSkill2(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_79_setUIPossiblePlaceToPutTrapFromSkill2)
HXDLIN(  79)		this->vActualTrap->setColorTransform((int)0,(int)1,(int)0,((Float)0.8),null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,setUIPossiblePlaceToPutTrapFromSkill2,(void))

void SkillLogicTrap_obj::setUIPlacedTrapFromSkill2(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_84_setUIPlacedTrapFromSkill2)
HXDLIN(  84)		this->vActualTrap->setColorTransform((int)1,(int)1,(int)1,(int)1,null(),null(),null(),null());
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,setUIPlacedTrapFromSkill2,(void))

bool SkillLogicTrap_obj::skill2ConditionToPutElement(){
            	HX_STACKFRAME(&_hx_pos_8bb4989bc5a1b769_88_skill2ConditionToPutElement)
HXLINE(  89)		Float thereIsAPlayer = ((Float)((int)3 * this->vActualTrap->get_width()) / (Float)(int)2);
HXDLIN(  89)		bool thereIsAPlayer1 = ::GlobalGameData_obj::thereIsPlayer(thereIsAPlayer,::flixel::FlxG_obj::mouse->x,::flixel::FlxG_obj::mouse->y);
HXLINE(  90)		Float isOnSurface = this->vActualTrap->get_width();
HXDLIN(  90)		int isOnSurface1 = ::flixel::FlxG_obj::mouse->x;
HXDLIN(  90)		int isOnSurface2 = ::flixel::FlxG_obj::mouse->y;
HXDLIN(  90)		bool isOnSurface3 = ::GlobalGameData_obj::itsOnASurface(isOnSurface,isOnSurface1,::Std_obj::_hx_int((isOnSurface2 - ((Float)this->vActualTrap->get_height() / (Float)(int)2))));
HXLINE(  91)		int thereIsACoin = ::flixel::FlxG_obj::mouse->x;
HXDLIN(  91)		int thereIsACoin1 = ::flixel::FlxG_obj::mouse->y;
HXDLIN(  91)		Float thereIsACoin2 = (thereIsACoin1 - ((Float)this->vActualTrap->get_height() / (Float)(int)2));
HXDLIN(  91)		 ::flixel::group::FlxTypedGroup thereIsACoin3 = ::GlobalGameData_obj::vPlayer1->vCoins;
HXDLIN(  91)		bool thereIsACoin4 = ::GlobalGameData_obj::thereIsACoinHere(thereIsACoin,thereIsACoin2,thereIsACoin3,((Float)((int)3 * this->vActualTrap->get_width()) / (Float)(int)2));
HXLINE(  93)		bool _hx_tmp;
HXDLIN(  93)		bool _hx_tmp1;
HXDLIN(  93)		if (hx::IsNotNull( this->vActualTrap )) {
HXLINE(  93)			_hx_tmp1 = !(thereIsAPlayer1);
            		}
            		else {
HXLINE(  93)			_hx_tmp1 = false;
            		}
HXDLIN(  93)		if (_hx_tmp1) {
HXLINE(  93)			_hx_tmp = isOnSurface3;
            		}
            		else {
HXLINE(  93)			_hx_tmp = false;
            		}
HXDLIN(  93)		if (_hx_tmp) {
HXLINE(  93)			return !(thereIsACoin4);
            		}
            		else {
HXLINE(  93)			return false;
            		}
HXDLIN(  93)		return false;
            	}


HX_DEFINE_DYNAMIC_FUNC0(SkillLogicTrap_obj,skill2ConditionToPutElement,return )


hx::ObjectPtr< SkillLogicTrap_obj > SkillLogicTrap_obj::__new(::String aTextDescription) {
	hx::ObjectPtr< SkillLogicTrap_obj > __this = new SkillLogicTrap_obj();
	__this->__construct(aTextDescription);
	return __this;
}

hx::ObjectPtr< SkillLogicTrap_obj > SkillLogicTrap_obj::__alloc(hx::Ctx *_hx_ctx,::String aTextDescription) {
	SkillLogicTrap_obj *__this = (SkillLogicTrap_obj*)(hx::Ctx::alloc(_hx_ctx, sizeof(SkillLogicTrap_obj), true, "skill.SkillLogicTrap"));
	*(void **)__this = SkillLogicTrap_obj::_hx_vtable;
	__this->__construct(aTextDescription);
	return __this;
}

SkillLogicTrap_obj::SkillLogicTrap_obj()
{
}

void SkillLogicTrap_obj::__Mark(HX_MARK_PARAMS)
{
	HX_MARK_BEGIN_CLASS(SkillLogicTrap);
	HX_MARK_MEMBER_NAME(vTraps,"vTraps");
	HX_MARK_MEMBER_NAME(vTextDescription,"vTextDescription");
	HX_MARK_MEMBER_NAME(vSkillButton,"vSkillButton");
	HX_MARK_MEMBER_NAME(vActualTrap,"vActualTrap");
	HX_MARK_END_CLASS();
}

void SkillLogicTrap_obj::__Visit(HX_VISIT_PARAMS)
{
	HX_VISIT_MEMBER_NAME(vTraps,"vTraps");
	HX_VISIT_MEMBER_NAME(vTextDescription,"vTextDescription");
	HX_VISIT_MEMBER_NAME(vSkillButton,"vSkillButton");
	HX_VISIT_MEMBER_NAME(vActualTrap,"vActualTrap");
}

hx::Val SkillLogicTrap_obj::__Field(const ::String &inName,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"vTraps") ) { return hx::Val( vTraps ); }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"skillReset") ) { return hx::Val( skillReset_dyn() ); }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"vActualTrap") ) { return hx::Val( vActualTrap ); }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vSkillButton") ) { return hx::Val( vSkillButton ); }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"skillExecution") ) { return hx::Val( skillExecution_dyn() ); }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"vTextDescription") ) { return hx::Val( vTextDescription ); }
		if (HX_FIELD_EQ(inName,"preparationSkill") ) { return hx::Val( preparationSkill_dyn() ); }
		break;
	case 21:
		if (HX_FIELD_EQ(inName,"skillUpdateValidation") ) { return hx::Val( skillUpdateValidation_dyn() ); }
		break;
	case 25:
		if (HX_FIELD_EQ(inName,"setUIPlacedTrapFromSkill2") ) { return hx::Val( setUIPlacedTrapFromSkill2_dyn() ); }
		break;
	case 27:
		if (HX_FIELD_EQ(inName,"skill2ConditionToPutElement") ) { return hx::Val( skill2ConditionToPutElement_dyn() ); }
		break;
	case 37:
		if (HX_FIELD_EQ(inName,"setUIPossiblePlaceToPutTrapFromSkill2") ) { return hx::Val( setUIPossiblePlaceToPutTrapFromSkill2_dyn() ); }
		break;
	case 40:
		if (HX_FIELD_EQ(inName,"setUINotPossiblePlaceToPutTrapFromSkill2") ) { return hx::Val( setUINotPossiblePlaceToPutTrapFromSkill2_dyn() ); }
	}
	return super::__Field(inName,inCallProp);
}

hx::Val SkillLogicTrap_obj::__SetField(const ::String &inName,const hx::Val &inValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 6:
		if (HX_FIELD_EQ(inName,"vTraps") ) { vTraps=inValue.Cast<  ::flixel::group::FlxTypedGroup >(); return inValue; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"vActualTrap") ) { vActualTrap=inValue.Cast<  ::gameObjects::Trap >(); return inValue; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"vSkillButton") ) { vSkillButton=inValue.Cast<  ::skill::FlxButtonAnimationSkill >(); return inValue; }
		break;
	case 16:
		if (HX_FIELD_EQ(inName,"vTextDescription") ) { vTextDescription=inValue.Cast< ::String >(); return inValue; }
	}
	return super::__SetField(inName,inValue,inCallProp);
}

void SkillLogicTrap_obj::__GetFields(Array< ::String> &outFields)
{
	outFields->push(HX_HCSTRING("vTraps","\x90","\x9d","\x69","\xd7"));
	outFields->push(HX_HCSTRING("vTextDescription","\x79","\x65","\x6d","\x41"));
	outFields->push(HX_HCSTRING("vSkillButton","\x8d","\x8d","\x48","\xb5"));
	outFields->push(HX_HCSTRING("vActualTrap","\xb1","\xdf","\xb5","\xe8"));
	super::__GetFields(outFields);
};

#if HXCPP_SCRIPTABLE
static hx::StorageInfo SkillLogicTrap_obj_sMemberStorageInfo[] = {
	{hx::fsObject /*::flixel::group::FlxTypedGroup*/ ,(int)offsetof(SkillLogicTrap_obj,vTraps),HX_HCSTRING("vTraps","\x90","\x9d","\x69","\xd7")},
	{hx::fsString,(int)offsetof(SkillLogicTrap_obj,vTextDescription),HX_HCSTRING("vTextDescription","\x79","\x65","\x6d","\x41")},
	{hx::fsObject /*::skill::FlxButtonAnimationSkill*/ ,(int)offsetof(SkillLogicTrap_obj,vSkillButton),HX_HCSTRING("vSkillButton","\x8d","\x8d","\x48","\xb5")},
	{hx::fsObject /*::gameObjects::Trap*/ ,(int)offsetof(SkillLogicTrap_obj,vActualTrap),HX_HCSTRING("vActualTrap","\xb1","\xdf","\xb5","\xe8")},
	{ hx::fsUnknown, 0, null()}
};
static hx::StaticInfo *SkillLogicTrap_obj_sStaticStorageInfo = 0;
#endif

static ::String SkillLogicTrap_obj_sMemberFields[] = {
	HX_HCSTRING("vTraps","\x90","\x9d","\x69","\xd7"),
	HX_HCSTRING("vTextDescription","\x79","\x65","\x6d","\x41"),
	HX_HCSTRING("vSkillButton","\x8d","\x8d","\x48","\xb5"),
	HX_HCSTRING("vActualTrap","\xb1","\xdf","\xb5","\xe8"),
	HX_HCSTRING("preparationSkill","\x3a","\x3d","\xf4","\x17"),
	HX_HCSTRING("skillExecution","\xc7","\xbb","\xf6","\x62"),
	HX_HCSTRING("skillReset","\x7e","\x56","\x9a","\x35"),
	HX_HCSTRING("skillUpdateValidation","\x53","\x3f","\x46","\x75"),
	HX_HCSTRING("setUINotPossiblePlaceToPutTrapFromSkill2","\x73","\xf7","\xa8","\xaa"),
	HX_HCSTRING("setUIPossiblePlaceToPutTrapFromSkill2","\xac","\xa1","\x55","\x8e"),
	HX_HCSTRING("setUIPlacedTrapFromSkill2","\x0b","\x2f","\x98","\xc8"),
	HX_HCSTRING("skill2ConditionToPutElement","\x02","\xa0","\xed","\xed"),
	::String(null()) };

static void SkillLogicTrap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(SkillLogicTrap_obj::__mClass,"__mClass");
};

#ifdef HXCPP_VISIT_ALLOCS
static void SkillLogicTrap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(SkillLogicTrap_obj::__mClass,"__mClass");
};

#endif

hx::Class SkillLogicTrap_obj::__mClass;

void SkillLogicTrap_obj::__register()
{
	hx::Object *dummy = new SkillLogicTrap_obj;
	SkillLogicTrap_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("skill.SkillLogicTrap","\xf7","\xd0","\x27","\xc9");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &hx::Class_obj::GetNoStaticField;
	__mClass->mSetStaticField = &hx::Class_obj::SetNoStaticField;
	__mClass->mMarkFunc = SkillLogicTrap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(0 /* sStaticFields */);
	__mClass->mMembers = hx::Class_obj::dupFunctions(SkillLogicTrap_obj_sMemberFields);
	__mClass->mCanCast = hx::TCanCast< SkillLogicTrap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = SkillLogicTrap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = SkillLogicTrap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = SkillLogicTrap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace skill
