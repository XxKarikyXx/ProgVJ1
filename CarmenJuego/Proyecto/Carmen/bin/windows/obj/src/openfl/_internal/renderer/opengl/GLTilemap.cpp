// Generated by Haxe 3.4.2 (git build master @ 890f8c7)
#include <hxcpp.h>

#ifndef INCLUDED_95f339a1d026d52c
#define INCLUDED_95f339a1d026d52c
#include "hxMath.h"
#endif
#ifndef INCLUDED_Std
#include <Std.h>
#endif
#ifndef INCLUDED_haxe_io_Bytes
#include <haxe/io/Bytes.h>
#endif
#ifndef INCLUDED_lime__backend_native_NativeGLRenderContext
#include <lime/_backend/native/NativeGLRenderContext.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl_GLObject
#include <lime/graphics/opengl/GLObject.h>
#endif
#ifndef INCLUDED_lime_graphics_opengl__WebGLContext_WebGLContext_Impl_
#include <lime/graphics/opengl/_WebGLContext/WebGLContext_Impl_.h>
#endif
#ifndef INCLUDED_lime_utils_ArrayBufferView
#include <lime/utils/ArrayBufferView.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool_openfl_geom_Matrix
#include <lime/utils/ObjectPool_openfl_geom_Matrix.h>
#endif
#ifndef INCLUDED_lime_utils_ObjectPool_openfl_geom_Rectangle
#include <lime/utils/ObjectPool_openfl_geom_Rectangle.h>
#endif
#ifndef INCLUDED_lime_utils__DataPointer_DataPointer_Impl_
#include <lime/utils/_DataPointer/DataPointer_Impl_.h>
#endif
#ifndef INCLUDED_openfl__internal_renderer_opengl_GLTilemap
#include <openfl/_internal/renderer/opengl/GLTilemap.h>
#endif
#ifndef INCLUDED_openfl_display_BitmapData
#include <openfl/display/BitmapData.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObject
#include <openfl/display/DisplayObject.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectRenderer
#include <openfl/display/DisplayObjectRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_DisplayObjectShader
#include <openfl/display/DisplayObjectShader.h>
#endif
#ifndef INCLUDED_openfl_display_IBitmapDrawable
#include <openfl/display/IBitmapDrawable.h>
#endif
#ifndef INCLUDED_openfl_display_ITileContainer
#include <openfl/display/ITileContainer.h>
#endif
#ifndef INCLUDED_openfl_display_OpenGLRenderer
#include <openfl/display/OpenGLRenderer.h>
#endif
#ifndef INCLUDED_openfl_display_Shader
#include <openfl/display/Shader.h>
#endif
#ifndef INCLUDED_openfl_display_ShaderParameter_Float
#include <openfl/display/ShaderParameter_Float.h>
#endif
#ifndef INCLUDED_openfl_display_Tile
#include <openfl/display/Tile.h>
#endif
#ifndef INCLUDED_openfl_display_TileContainer
#include <openfl/display/TileContainer.h>
#endif
#ifndef INCLUDED_openfl_display_Tilemap
#include <openfl/display/Tilemap.h>
#endif
#ifndef INCLUDED_openfl_display_Tileset
#include <openfl/display/Tileset.h>
#endif
#ifndef INCLUDED_openfl_display__Tileset_TileData
#include <openfl/display/_Tileset/TileData.h>
#endif
#ifndef INCLUDED_openfl_events_EventDispatcher
#include <openfl/events/EventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_events_IEventDispatcher
#include <openfl/events/IEventDispatcher.h>
#endif
#ifndef INCLUDED_openfl_geom_ColorTransform
#include <openfl/geom/ColorTransform.h>
#endif
#ifndef INCLUDED_openfl_geom_Matrix
#include <openfl/geom/Matrix.h>
#endif
#ifndef INCLUDED_openfl_geom_Rectangle
#include <openfl/geom/Rectangle.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_52_buildBuffer,"openfl._internal.renderer.opengl.GLTilemap","buildBuffer",0xae03e005,"openfl._internal.renderer.opengl.GLTilemap.buildBuffer","openfl/_internal/renderer/opengl/GLTilemap.hx",52,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_78_buildBufferTileContainer,"openfl._internal.renderer.opengl.GLTilemap","buildBufferTileContainer",0x799cc4ee,"openfl._internal.renderer.opengl.GLTilemap.buildBufferTileContainer","openfl/_internal/renderer/opengl/GLTilemap.hx",78,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_302_flush,"openfl._internal.renderer.opengl.GLTilemap","flush",0x0f0f4cbb,"openfl._internal.renderer.opengl.GLTilemap.flush","openfl/_internal/renderer/opengl/GLTilemap.hx",302,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_409_render,"openfl._internal.renderer.opengl.GLTilemap","render",0xde22397f,"openfl._internal.renderer.opengl.GLTilemap.render","openfl/_internal/renderer/opengl/GLTilemap.hx",409,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_446_renderTileContainer,"openfl._internal.renderer.opengl.GLTilemap","renderTileContainer",0x17548734,"openfl._internal.renderer.opengl.GLTilemap.renderTileContainer","openfl/_internal/renderer/opengl/GLTilemap.hx",446,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_506_renderMask,"openfl._internal.renderer.opengl.GLTilemap","renderMask",0xc145d20b,"openfl._internal.renderer.opengl.GLTilemap.renderMask","openfl/_internal/renderer/opengl/GLTilemap.hx",506,0xf59b2d1b)
HX_LOCAL_STACK_FRAME(_hx_pos_40a075b64d21c9aa_592_resizeBuffer,"openfl._internal.renderer.opengl.GLTilemap","resizeBuffer",0x8619ccfd,"openfl._internal.renderer.opengl.GLTilemap.resizeBuffer","openfl/_internal/renderer/opengl/GLTilemap.hx",592,0xf59b2d1b)
namespace openfl{
namespace _internal{
namespace renderer{
namespace opengl{

void GLTilemap_obj::__construct() { }

Dynamic GLTilemap_obj::__CreateEmpty() { return new GLTilemap_obj; }

void *GLTilemap_obj::_hx_vtable = 0;

Dynamic GLTilemap_obj::__Create(hx::DynamicArray inArgs)
{
	hx::ObjectPtr< GLTilemap_obj > _hx_result = new GLTilemap_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool GLTilemap_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x22e44b0b;
}

int GLTilemap_obj::bufferLength;

int GLTilemap_obj::bufferPosition;

 ::openfl::geom::ColorTransform GLTilemap_obj::cacheColorTransform;

 ::openfl::display::BitmapData GLTilemap_obj::currentBitmapData;

 ::openfl::display::Shader GLTilemap_obj::currentShader;

int GLTilemap_obj::lastFlushedPosition;

 ::openfl::display::BitmapData GLTilemap_obj::lastUsedBitmapData;

 ::openfl::display::Shader GLTilemap_obj::lastUsedShader;

void GLTilemap_obj::buildBuffer( ::openfl::display::Tilemap tilemap, ::openfl::display::OpenGLRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_52_buildBuffer)
HXLINE(  54)		bool _hx_tmp;
HXDLIN(  54)		bool _hx_tmp1;
HXDLIN(  54)		if (!(!(tilemap->_hx___renderable))) {
HXLINE(  54)			_hx_tmp1 = (tilemap->_hx___group->_hx___tiles->length == (int)0);
            		}
            		else {
HXLINE(  54)			_hx_tmp1 = true;
            		}
HXDLIN(  54)		if (!(_hx_tmp1)) {
HXLINE(  54)			_hx_tmp = (tilemap->_hx___worldAlpha <= (int)0);
            		}
            		else {
HXLINE(  54)			_hx_tmp = true;
            		}
HXDLIN(  54)		if (_hx_tmp) {
HXLINE(  54)			return;
            		}
HXLINE(  56)		::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferLength = (int)0;
HXLINE(  57)		::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition = (int)0;
HXLINE(  59)		 ::openfl::geom::Rectangle rect = ::openfl::geom::Rectangle_obj::_hx___pool->get();
HXLINE(  60)		 ::openfl::geom::Matrix matrix = ::openfl::geom::Matrix_obj::_hx___pool->get();
HXLINE(  61)		 ::openfl::geom::Matrix parentTransform = ::openfl::geom::Matrix_obj::_hx___pool->get();
HXLINE(  63)		int stride = (int)4;
HXLINE(  64)		if (tilemap->tileAlphaEnabled) {
HXLINE(  64)			stride = (stride + (int)1);
            		}
HXLINE(  65)		if (tilemap->tileColorTransformEnabled) {
HXLINE(  65)			stride = (stride + (int)8);
            		}
HXLINE(  67)		::openfl::_internal::renderer::opengl::GLTilemap_obj::buildBufferTileContainer(tilemap,tilemap->_hx___group,renderer,parentTransform,stride,tilemap->_hx___tileset,tilemap->tileAlphaEnabled,tilemap->_hx___worldAlpha,tilemap->tileColorTransformEnabled,tilemap->_hx___worldColorTransform,null(),rect,matrix);
HXLINE(  69)		tilemap->_hx___bufferLength = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferLength;
HXLINE(  71)		::openfl::geom::Rectangle_obj::_hx___pool->release(rect);
HXLINE(  72)		::openfl::geom::Matrix_obj::_hx___pool->release(matrix);
HXLINE(  73)		::openfl::geom::Matrix_obj::_hx___pool->release(parentTransform);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,buildBuffer,(void))

void GLTilemap_obj::buildBufferTileContainer( ::openfl::display::Tilemap tilemap, ::openfl::display::TileContainer group, ::openfl::display::OpenGLRenderer renderer, ::openfl::geom::Matrix parentTransform,int stride, ::openfl::display::Tileset defaultTileset,bool alphaEnabled,Float worldAlpha,bool colorTransformEnabled, ::openfl::geom::ColorTransform defaultColorTransform, ::openfl::display::BitmapData cacheBitmapData, ::openfl::geom::Rectangle rect, ::openfl::geom::Matrix matrix){
            	HX_GC_STACKFRAME(&_hx_pos_40a075b64d21c9aa_78_buildBufferTileContainer)
HXLINE(  80)		 ::openfl::geom::Matrix tileTransform = ::openfl::geom::Matrix_obj::_hx___pool->get();
HXLINE(  81)		bool roundPixels = renderer->_hx___roundPixels;
HXLINE(  83)		::Array< ::Dynamic> tiles = group->_hx___tiles;
HXLINE(  84)		int length = group->__length;
HXLINE(  86)		int _hx_tmp = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition;
HXDLIN(  86)		::openfl::_internal::renderer::opengl::GLTilemap_obj::resizeBuffer(tilemap,(_hx_tmp + ((length * stride) * (int)6)));
HXLINE(  87)		 ::lime::utils::ArrayBufferView _hx___bufferData = tilemap->_hx___bufferData;
HXLINE(  89)		int cacheLength;
HXDLIN(  89)		int cacheBufferPosition;
HXLINE(  90)		 ::Dynamic tile;
HXDLIN(  90)		 ::openfl::display::Tileset tileset;
HXDLIN(  90)		Float alpha;
HXDLIN(  90)		bool visible;
HXDLIN(  90)		 ::openfl::geom::ColorTransform colorTransform = null();
HXDLIN(  90)		int id;
HXDLIN(  90)		 ::openfl::display::_Tileset::TileData tileData;
HXDLIN(  90)		 ::openfl::geom::Rectangle tileRect;
HXDLIN(  90)		 ::openfl::display::BitmapData bitmapData;
HXLINE(  91)		Float tileWidth;
HXDLIN(  91)		Float tileHeight;
HXDLIN(  91)		Float uvX;
HXDLIN(  91)		Float uvY;
HXDLIN(  91)		Float uvHeight;
HXDLIN(  91)		Float uvWidth;
HXDLIN(  91)		int offset;
HXLINE(  92)		Float x;
HXDLIN(  92)		Float y;
HXDLIN(  92)		Float x2;
HXDLIN(  92)		Float y2;
HXDLIN(  92)		Float x3;
HXDLIN(  92)		Float y3;
HXDLIN(  92)		Float x4;
HXDLIN(  92)		Float y4;
HXLINE(  94)		int alphaPosition = (int)4;
HXLINE(  95)		int ctPosition;
HXDLIN(  95)		if (alphaEnabled) {
HXLINE(  95)			ctPosition = (int)5;
            		}
            		else {
HXLINE(  95)			ctPosition = (int)4;
            		}
HXLINE(  97)		{
HXLINE(  97)			int _g = (int)0;
HXDLIN(  97)			while((_g < tiles->length)){
HXLINE(  97)				 ::openfl::display::Tile tile1 = tiles->__get(_g).StaticCast<  ::openfl::display::Tile >();
HXDLIN(  97)				_g = (_g + (int)1);
HXLINE(  99)				Float _hx_tmp1 = -(tile1->get_originX());
HXDLIN(  99)				tileTransform->setTo((int)1,(int)0,(int)0,(int)1,_hx_tmp1,-(tile1->get_originY()));
HXLINE( 100)				tileTransform->concat(tile1->get_matrix());
HXLINE( 101)				tileTransform->concat(parentTransform);
HXLINE( 103)				if (roundPixels) {
HXLINE( 105)					tileTransform->tx = ::Math_obj::round(tileTransform->tx);
HXLINE( 106)					tileTransform->ty = ::Math_obj::round(tileTransform->ty);
            				}
HXLINE( 110)				if (hx::IsNotNull( tile1->get_tileset() )) {
HXLINE( 110)					tileset = tile1->get_tileset();
            				}
            				else {
HXLINE( 110)					tileset = defaultTileset;
            				}
HXLINE( 112)				alpha = (tile1->get_alpha() * worldAlpha);
HXLINE( 113)				visible = tile1->get_visible();
HXLINE( 114)				bool _hx_tmp2;
HXDLIN( 114)				if (!(!(visible))) {
HXLINE( 114)					_hx_tmp2 = (alpha <= (int)0);
            				}
            				else {
HXLINE( 114)					_hx_tmp2 = true;
            				}
HXDLIN( 114)				if (_hx_tmp2) {
HXLINE( 114)					continue;
            				}
HXLINE( 116)				if (colorTransformEnabled) {
HXLINE( 118)					if (hx::IsNotNull( tile1->get_colorTransform() )) {
HXLINE( 120)						if (hx::IsNull( defaultColorTransform )) {
HXLINE( 122)							colorTransform = tile1->get_colorTransform();
            						}
            						else {
HXLINE( 126)							if (hx::IsNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::cacheColorTransform )) {
HXLINE( 128)								::openfl::_internal::renderer::opengl::GLTilemap_obj::cacheColorTransform =  ::openfl::geom::ColorTransform_obj::__alloc( HX_CTX ,null(),null(),null(),null(),null(),null(),null(),null());
            							}
HXLINE( 132)							colorTransform = ::openfl::_internal::renderer::opengl::GLTilemap_obj::cacheColorTransform;
HXLINE( 133)							Float defaultColorTransform1 = defaultColorTransform->redMultiplier;
HXDLIN( 133)							colorTransform->redMultiplier = (defaultColorTransform1 * tile1->get_colorTransform()->redMultiplier);
HXLINE( 134)							Float defaultColorTransform2 = defaultColorTransform->greenMultiplier;
HXDLIN( 134)							colorTransform->greenMultiplier = (defaultColorTransform2 * tile1->get_colorTransform()->greenMultiplier);
HXLINE( 135)							Float defaultColorTransform3 = defaultColorTransform->blueMultiplier;
HXDLIN( 135)							colorTransform->blueMultiplier = (defaultColorTransform3 * tile1->get_colorTransform()->blueMultiplier);
HXLINE( 136)							Float defaultColorTransform4 = defaultColorTransform->alphaMultiplier;
HXDLIN( 136)							colorTransform->alphaMultiplier = (defaultColorTransform4 * tile1->get_colorTransform()->alphaMultiplier);
HXLINE( 137)							Float defaultColorTransform5 = defaultColorTransform->redOffset;
HXDLIN( 137)							colorTransform->redOffset = (defaultColorTransform5 + tile1->get_colorTransform()->redOffset);
HXLINE( 138)							Float defaultColorTransform6 = defaultColorTransform->greenOffset;
HXDLIN( 138)							colorTransform->greenOffset = (defaultColorTransform6 + tile1->get_colorTransform()->greenOffset);
HXLINE( 139)							Float defaultColorTransform7 = defaultColorTransform->blueOffset;
HXDLIN( 139)							colorTransform->blueOffset = (defaultColorTransform7 + tile1->get_colorTransform()->blueOffset);
HXLINE( 140)							Float defaultColorTransform8 = defaultColorTransform->alphaOffset;
HXDLIN( 140)							colorTransform->alphaOffset = (defaultColorTransform8 + tile1->get_colorTransform()->alphaOffset);
            						}
            					}
            					else {
HXLINE( 146)						colorTransform = defaultColorTransform;
            					}
            				}
HXLINE( 152)				if (!(alphaEnabled)) {
HXLINE( 152)					alpha = (int)1;
            				}
HXLINE( 154)				if ((tile1->__length > (int)0)) {
HXLINE( 156)					cacheLength = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferLength;
HXLINE( 157)					cacheBufferPosition = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition;
HXLINE( 159)					::openfl::_internal::renderer::opengl::GLTilemap_obj::buildBufferTileContainer(tilemap,( ( ::openfl::display::TileContainer)(tile1) ),renderer,tileTransform,stride,tileset,alphaEnabled,alpha,colorTransformEnabled,colorTransform,cacheBitmapData,rect,matrix);
HXLINE( 161)					::openfl::_internal::renderer::opengl::GLTilemap_obj::resizeBuffer(tilemap,(cacheLength + (::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition - cacheBufferPosition)));
HXLINE( 162)					_hx___bufferData = tilemap->_hx___bufferData;
            				}
            				else {
HXLINE( 166)					if (hx::IsNull( tileset )) {
HXLINE( 166)						continue;
            					}
HXLINE( 168)					id = tile1->get_id();
HXLINE( 170)					bitmapData = tileset->_hx___bitmapData;
HXLINE( 171)					if (hx::IsNull( bitmapData )) {
HXLINE( 171)						continue;
            					}
HXLINE( 173)					if ((id == (int)-1)) {
HXLINE( 175)						tileRect = tile1->get_rect();
HXLINE( 176)						bool _hx_tmp3;
HXDLIN( 176)						bool _hx_tmp4;
HXDLIN( 176)						if (hx::IsNotNull( tileRect )) {
HXLINE( 176)							_hx_tmp4 = (tileRect->width <= (int)0);
            						}
            						else {
HXLINE( 176)							_hx_tmp4 = true;
            						}
HXDLIN( 176)						if (!(_hx_tmp4)) {
HXLINE( 176)							_hx_tmp3 = (tileRect->height <= (int)0);
            						}
            						else {
HXLINE( 176)							_hx_tmp3 = true;
            						}
HXDLIN( 176)						if (_hx_tmp3) {
HXLINE( 176)							continue;
            						}
HXLINE( 178)						uvX = ((Float)tileRect->x / (Float)bitmapData->width);
HXLINE( 179)						uvY = ((Float)tileRect->y / (Float)bitmapData->height);
HXLINE( 180)						Float uvWidth1 = tileRect->get_right();
HXDLIN( 180)						uvWidth = ((Float)uvWidth1 / (Float)bitmapData->width);
HXLINE( 181)						Float uvHeight1 = tileRect->get_bottom();
HXDLIN( 181)						uvHeight = ((Float)uvHeight1 / (Float)bitmapData->height);
            					}
            					else {
HXLINE( 185)						tileData = tileset->_hx___data->__get(id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 186)						if (hx::IsNull( tileData )) {
HXLINE( 186)							continue;
            						}
HXLINE( 188)						rect->setTo(tileData->x,tileData->y,tileData->width,tileData->height);
HXLINE( 189)						tileRect = rect;
HXLINE( 191)						uvX = tileData->_hx___uvX;
HXLINE( 192)						uvY = tileData->_hx___uvY;
HXLINE( 193)						uvWidth = tileData->_hx___uvWidth;
HXLINE( 194)						uvHeight = tileData->_hx___uvHeight;
            					}
HXLINE( 198)					tileWidth = tileRect->width;
HXLINE( 199)					tileHeight = tileRect->height;
HXLINE( 201)					Float x1 = ((int)0 * tileTransform->a);
HXDLIN( 201)					x = ((x1 + ((int)0 * tileTransform->c)) + tileTransform->tx);
HXLINE( 202)					Float y1 = ((int)0 * tileTransform->b);
HXDLIN( 202)					y = ((y1 + ((int)0 * tileTransform->d)) + tileTransform->ty);
HXLINE( 203)					Float x21 = (tileWidth * tileTransform->a);
HXDLIN( 203)					x2 = ((x21 + ((int)0 * tileTransform->c)) + tileTransform->tx);
HXLINE( 204)					Float y21 = (tileWidth * tileTransform->b);
HXDLIN( 204)					y2 = ((y21 + ((int)0 * tileTransform->d)) + tileTransform->ty);
HXLINE( 205)					Float x31 = ((int)0 * tileTransform->a);
HXDLIN( 205)					x3 = ((x31 + (tileHeight * tileTransform->c)) + tileTransform->tx);
HXLINE( 206)					Float y31 = ((int)0 * tileTransform->b);
HXDLIN( 206)					y3 = ((y31 + (tileHeight * tileTransform->d)) + tileTransform->ty);
HXLINE( 207)					Float x41 = (tileWidth * tileTransform->a);
HXDLIN( 207)					x4 = ((x41 + (tileHeight * tileTransform->c)) + tileTransform->tx);
HXLINE( 208)					Float y41 = (tileWidth * tileTransform->b);
HXDLIN( 208)					y4 = ((y41 + (tileHeight * tileTransform->d)) + tileTransform->ty);
HXLINE( 210)					offset = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition;
HXLINE( 212)					{
HXLINE( 212)						int _hx___bufferData1 = _hx___bufferData->byteOffset;
HXDLIN( 212)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData1 + (offset * (int)4)),x);
            					}
HXLINE( 213)					{
HXLINE( 213)						int _hx___bufferData2 = _hx___bufferData->byteOffset;
HXDLIN( 213)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData2 + ((offset + (int)1) * (int)4)),y);
            					}
HXLINE( 214)					{
HXLINE( 214)						int _hx___bufferData3 = _hx___bufferData->byteOffset;
HXDLIN( 214)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData3 + ((offset + (int)2) * (int)4)),uvX);
            					}
HXLINE( 215)					{
HXLINE( 215)						int _hx___bufferData4 = _hx___bufferData->byteOffset;
HXDLIN( 215)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData4 + ((offset + (int)3) * (int)4)),uvY);
            					}
HXLINE( 217)					{
HXLINE( 217)						int _hx___bufferData5 = _hx___bufferData->byteOffset;
HXDLIN( 217)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData5 + ((offset + stride) * (int)4)),x2);
            					}
HXLINE( 218)					{
HXLINE( 218)						int _hx___bufferData6 = _hx___bufferData->byteOffset;
HXDLIN( 218)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData6 + (((offset + stride) + (int)1) * (int)4)),y2);
            					}
HXLINE( 219)					{
HXLINE( 219)						int _hx___bufferData7 = _hx___bufferData->byteOffset;
HXDLIN( 219)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData7 + (((offset + stride) + (int)2) * (int)4)),uvWidth);
            					}
HXLINE( 220)					{
HXLINE( 220)						int _hx___bufferData8 = _hx___bufferData->byteOffset;
HXDLIN( 220)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData8 + (((offset + stride) + (int)3) * (int)4)),uvY);
            					}
HXLINE( 222)					{
HXLINE( 222)						int _hx___bufferData9 = _hx___bufferData->byteOffset;
HXDLIN( 222)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData9 + ((offset + (stride * (int)2)) * (int)4)),x3);
            					}
HXLINE( 223)					{
HXLINE( 223)						int _hx___bufferData10 = _hx___bufferData->byteOffset;
HXDLIN( 223)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData10 + (((offset + (stride * (int)2)) + (int)1) * (int)4)),y3);
            					}
HXLINE( 224)					{
HXLINE( 224)						int _hx___bufferData11 = _hx___bufferData->byteOffset;
HXDLIN( 224)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData11 + (((offset + (stride * (int)2)) + (int)2) * (int)4)),uvX);
            					}
HXLINE( 225)					{
HXLINE( 225)						int _hx___bufferData12 = _hx___bufferData->byteOffset;
HXDLIN( 225)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData12 + (((offset + (stride * (int)2)) + (int)3) * (int)4)),uvHeight);
            					}
HXLINE( 227)					{
HXLINE( 227)						int _hx___bufferData13 = _hx___bufferData->byteOffset;
HXDLIN( 227)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData13 + ((offset + (stride * (int)3)) * (int)4)),x3);
            					}
HXLINE( 228)					{
HXLINE( 228)						int _hx___bufferData14 = _hx___bufferData->byteOffset;
HXDLIN( 228)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData14 + (((offset + (stride * (int)3)) + (int)1) * (int)4)),y3);
            					}
HXLINE( 229)					{
HXLINE( 229)						int _hx___bufferData15 = _hx___bufferData->byteOffset;
HXDLIN( 229)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData15 + (((offset + (stride * (int)3)) + (int)2) * (int)4)),uvX);
            					}
HXLINE( 230)					{
HXLINE( 230)						int _hx___bufferData16 = _hx___bufferData->byteOffset;
HXDLIN( 230)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData16 + (((offset + (stride * (int)3)) + (int)3) * (int)4)),uvHeight);
            					}
HXLINE( 232)					{
HXLINE( 232)						int _hx___bufferData17 = _hx___bufferData->byteOffset;
HXDLIN( 232)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData17 + ((offset + (stride * (int)4)) * (int)4)),x2);
            					}
HXLINE( 233)					{
HXLINE( 233)						int _hx___bufferData18 = _hx___bufferData->byteOffset;
HXDLIN( 233)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData18 + (((offset + (stride * (int)4)) + (int)1) * (int)4)),y2);
            					}
HXLINE( 234)					{
HXLINE( 234)						int _hx___bufferData19 = _hx___bufferData->byteOffset;
HXDLIN( 234)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData19 + (((offset + (stride * (int)4)) + (int)2) * (int)4)),uvWidth);
            					}
HXLINE( 235)					{
HXLINE( 235)						int _hx___bufferData20 = _hx___bufferData->byteOffset;
HXDLIN( 235)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData20 + (((offset + (stride * (int)4)) + (int)3) * (int)4)),uvY);
            					}
HXLINE( 237)					{
HXLINE( 237)						int _hx___bufferData21 = _hx___bufferData->byteOffset;
HXDLIN( 237)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData21 + ((offset + (stride * (int)5)) * (int)4)),x4);
            					}
HXLINE( 238)					{
HXLINE( 238)						int _hx___bufferData22 = _hx___bufferData->byteOffset;
HXDLIN( 238)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData22 + (((offset + (stride * (int)5)) + (int)1) * (int)4)),y4);
            					}
HXLINE( 239)					{
HXLINE( 239)						int _hx___bufferData23 = _hx___bufferData->byteOffset;
HXDLIN( 239)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData23 + (((offset + (stride * (int)5)) + (int)2) * (int)4)),uvWidth);
            					}
HXLINE( 240)					{
HXLINE( 240)						int _hx___bufferData24 = _hx___bufferData->byteOffset;
HXDLIN( 240)						::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData24 + (((offset + (stride * (int)5)) + (int)3) * (int)4)),uvHeight);
            					}
HXLINE( 242)					if (alphaEnabled) {
HXLINE( 244)						int _g1 = (int)0;
HXDLIN( 244)						while((_g1 < (int)6)){
HXLINE( 244)							_g1 = (_g1 + (int)1);
HXDLIN( 244)							int i = (_g1 - (int)1);
HXLINE( 246)							{
HXLINE( 246)								int _hx___bufferData25 = _hx___bufferData->byteOffset;
HXDLIN( 246)								::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData25 + (((offset + (stride * i)) + alphaPosition) * (int)4)),alpha);
            							}
            						}
            					}
HXLINE( 252)					if (colorTransformEnabled) {
HXLINE( 254)						if (hx::IsNotNull( colorTransform )) {
HXLINE( 256)							int _g11 = (int)0;
HXDLIN( 256)							while((_g11 < (int)6)){
HXLINE( 256)								_g11 = (_g11 + (int)1);
HXDLIN( 256)								int i1 = (_g11 - (int)1);
HXLINE( 258)								{
HXLINE( 258)									Float val = colorTransform->redMultiplier;
HXDLIN( 258)									{
HXLINE( 258)										int _hx___bufferData26 = _hx___bufferData->byteOffset;
HXDLIN( 258)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData26 + (((offset + (stride * i1)) + ctPosition) * (int)4)),val);
            									}
            								}
HXLINE( 259)								{
HXLINE( 259)									Float val1 = colorTransform->greenMultiplier;
HXDLIN( 259)									{
HXLINE( 259)										int _hx___bufferData27 = _hx___bufferData->byteOffset;
HXDLIN( 259)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData27 + ((((offset + (stride * i1)) + ctPosition) + (int)1) * (int)4)),val1);
            									}
            								}
HXLINE( 260)								{
HXLINE( 260)									Float val2 = colorTransform->blueMultiplier;
HXDLIN( 260)									{
HXLINE( 260)										int _hx___bufferData28 = _hx___bufferData->byteOffset;
HXDLIN( 260)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData28 + ((((offset + (stride * i1)) + ctPosition) + (int)2) * (int)4)),val2);
            									}
            								}
HXLINE( 261)								{
HXLINE( 261)									Float val3 = colorTransform->alphaMultiplier;
HXDLIN( 261)									{
HXLINE( 261)										int _hx___bufferData29 = _hx___bufferData->byteOffset;
HXDLIN( 261)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData29 + ((((offset + (stride * i1)) + ctPosition) + (int)3) * (int)4)),val3);
            									}
            								}
HXLINE( 263)								{
HXLINE( 263)									Float val4 = colorTransform->redOffset;
HXDLIN( 263)									{
HXLINE( 263)										int _hx___bufferData30 = _hx___bufferData->byteOffset;
HXDLIN( 263)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData30 + ((((offset + (stride * i1)) + ctPosition) + (int)4) * (int)4)),val4);
            									}
            								}
HXLINE( 264)								{
HXLINE( 264)									Float val5 = colorTransform->greenOffset;
HXDLIN( 264)									{
HXLINE( 264)										int _hx___bufferData31 = _hx___bufferData->byteOffset;
HXDLIN( 264)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData31 + ((((offset + (stride * i1)) + ctPosition) + (int)5) * (int)4)),val5);
            									}
            								}
HXLINE( 265)								{
HXLINE( 265)									Float val6 = colorTransform->blueOffset;
HXDLIN( 265)									{
HXLINE( 265)										int _hx___bufferData32 = _hx___bufferData->byteOffset;
HXDLIN( 265)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData32 + ((((offset + (stride * i1)) + ctPosition) + (int)6) * (int)4)),val6);
            									}
            								}
HXLINE( 266)								{
HXLINE( 266)									Float val7 = colorTransform->alphaOffset;
HXDLIN( 266)									{
HXLINE( 266)										int _hx___bufferData33 = _hx___bufferData->byteOffset;
HXDLIN( 266)										::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData33 + ((((offset + (stride * i1)) + ctPosition) + (int)7) * (int)4)),val7);
            									}
            								}
            							}
            						}
            						else {
HXLINE( 272)							int _g12 = (int)0;
HXDLIN( 272)							while((_g12 < (int)6)){
HXLINE( 272)								_g12 = (_g12 + (int)1);
HXDLIN( 272)								int i2 = (_g12 - (int)1);
HXLINE( 274)								{
HXLINE( 274)									int _hx___bufferData34 = _hx___bufferData->byteOffset;
HXDLIN( 274)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData34 + (((offset + (stride * i2)) + ctPosition) * (int)4)),(int)1);
            								}
HXLINE( 275)								{
HXLINE( 275)									int _hx___bufferData35 = _hx___bufferData->byteOffset;
HXDLIN( 275)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData35 + ((((offset + (stride * i2)) + ctPosition) + (int)1) * (int)4)),(int)1);
            								}
HXLINE( 276)								{
HXLINE( 276)									int _hx___bufferData36 = _hx___bufferData->byteOffset;
HXDLIN( 276)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData36 + ((((offset + (stride * i2)) + ctPosition) + (int)2) * (int)4)),(int)1);
            								}
HXLINE( 277)								{
HXLINE( 277)									int _hx___bufferData37 = _hx___bufferData->byteOffset;
HXDLIN( 277)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData37 + ((((offset + (stride * i2)) + ctPosition) + (int)3) * (int)4)),(int)1);
            								}
HXLINE( 279)								{
HXLINE( 279)									int _hx___bufferData38 = _hx___bufferData->byteOffset;
HXDLIN( 279)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData38 + ((((offset + (stride * i2)) + ctPosition) + (int)4) * (int)4)),(int)0);
            								}
HXLINE( 280)								{
HXLINE( 280)									int _hx___bufferData39 = _hx___bufferData->byteOffset;
HXDLIN( 280)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData39 + ((((offset + (stride * i2)) + ctPosition) + (int)5) * (int)4)),(int)0);
            								}
HXLINE( 281)								{
HXLINE( 281)									int _hx___bufferData40 = _hx___bufferData->byteOffset;
HXDLIN( 281)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData40 + ((((offset + (stride * i2)) + ctPosition) + (int)6) * (int)4)),(int)0);
            								}
HXLINE( 282)								{
HXLINE( 282)									int _hx___bufferData41 = _hx___bufferData->byteOffset;
HXDLIN( 282)									::__hxcpp_memory_set_float(_hx___bufferData->buffer->b,(_hx___bufferData41 + ((((offset + (stride * i2)) + ctPosition) + (int)7) * (int)4)),(int)0);
            								}
            							}
            						}
            					}
HXLINE( 290)					 ::Dynamic _hx_tmp5 = hx::ClassOf< ::openfl::_internal::renderer::opengl::GLTilemap >();
HXDLIN( 290)					::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition = (::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition + (stride * (int)6));
            				}
            			}
            		}
HXLINE( 296)		::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferLength = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition;
HXLINE( 297)		::openfl::geom::Matrix_obj::_hx___pool->release(tileTransform);
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC13(GLTilemap_obj,buildBufferTileContainer,(void))

void GLTilemap_obj::flush( ::openfl::display::Tilemap tilemap, ::openfl::display::OpenGLRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_302_flush)
HXLINE( 304)		if (hx::IsNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader )) {
HXLINE( 306)			::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader = renderer->_hx___defaultDisplayShader;
            		}
HXLINE( 310)		bool updatedBuffer = true;
HXLINE( 312)		bool _hx_tmp;
HXDLIN( 312)		bool _hx_tmp1;
HXDLIN( 312)		if ((::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition > ::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition)) {
HXLINE( 312)			_hx_tmp1 = hx::IsNotNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData );
            		}
            		else {
HXLINE( 312)			_hx_tmp1 = false;
            		}
HXDLIN( 312)		if (_hx_tmp1) {
HXLINE( 312)			_hx_tmp = hx::IsNotNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader );
            		}
            		else {
HXLINE( 312)			_hx_tmp = false;
            		}
HXDLIN( 312)		if (_hx_tmp) {
HXLINE( 314)			 ::lime::_backend::native::NativeGLRenderContext gl = renderer->_hx___gl;
HXLINE( 316)			 ::openfl::display::Shader shader = renderer->_hx___initDisplayShader(::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader);
HXLINE( 317)			renderer->setShader(shader);
HXLINE( 318)			bool _hx_tmp2;
HXDLIN( 318)			if (renderer->_hx___allowSmoothing) {
HXLINE( 318)				_hx_tmp2 = tilemap->smoothing;
            			}
            			else {
HXLINE( 318)				_hx_tmp2 = false;
            			}
HXDLIN( 318)			renderer->applyBitmapData(::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData,_hx_tmp2,null());
HXLINE( 319)			renderer->applyMatrix(renderer->_hx___getMatrix(tilemap->_hx___renderTransform));
HXLINE( 321)			if (tilemap->tileAlphaEnabled) {
HXLINE( 323)				renderer->useAlphaArray();
            			}
            			else {
HXLINE( 327)				renderer->applyAlpha(tilemap->_hx___worldAlpha);
            			}
HXLINE( 331)			if (tilemap->tileColorTransformEnabled) {
HXLINE( 333)				renderer->applyHasColorTransform(true);
HXLINE( 334)				renderer->useColorTransformArray();
            			}
            			else {
HXLINE( 338)				renderer->applyColorTransform(tilemap->_hx___worldColorTransform);
            			}
HXLINE( 342)			renderer->updateShader();
HXLINE( 344)			int stride = (int)4;
HXLINE( 345)			if (tilemap->tileAlphaEnabled) {
HXLINE( 345)				stride = (stride + (int)1);
            			}
HXLINE( 346)			if (tilemap->tileColorTransformEnabled) {
HXLINE( 346)				stride = (stride + (int)8);
            			}
HXLINE( 348)			bool _hx_tmp3;
HXDLIN( 348)			if (hx::IsNotNull( tilemap->_hx___buffer )) {
HXLINE( 348)				_hx_tmp3 = hx::IsNotEq( tilemap->_hx___bufferContext,gl );
            			}
            			else {
HXLINE( 348)				_hx_tmp3 = true;
            			}
HXDLIN( 348)			if (_hx_tmp3) {
HXLINE( 350)				tilemap->_hx___bufferContext = gl;
HXLINE( 351)				tilemap->_hx___buffer = gl->createBuffer();
            			}
HXLINE( 355)			gl->bindBuffer(gl->ARRAY_BUFFER,tilemap->_hx___buffer);
HXLINE( 357)			if (updatedBuffer) {
HXLINE( 359)				::lime::graphics::opengl::_WebGLContext::WebGLContext_Impl__obj::bufferData(gl,gl->ARRAY_BUFFER,tilemap->_hx___bufferData,gl->DYNAMIC_DRAW);
            			}
HXLINE( 363)			if (hx::IsNotNull( shader->_hx___position )) {
HXLINE( 363)				int indx = shader->_hx___position->index;
HXDLIN( 363)				int type = gl->FLOAT;
HXDLIN( 363)				gl->vertexAttribPointer(indx,(int)2,type,false,(stride * (int)4),::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((int)0));
            			}
HXLINE( 364)			if (hx::IsNotNull( shader->_hx___textureCoord )) {
HXLINE( 364)				int indx1 = shader->_hx___textureCoord->index;
HXDLIN( 364)				int type1 = gl->FLOAT;
HXDLIN( 364)				gl->vertexAttribPointer(indx1,(int)2,type1,false,(stride * (int)4),::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((int)8));
            			}
HXLINE( 366)			if (tilemap->tileAlphaEnabled) {
HXLINE( 368)				if (hx::IsNotNull( shader->_hx___alpha )) {
HXLINE( 368)					int indx2 = shader->_hx___alpha->index;
HXDLIN( 368)					int type2 = gl->FLOAT;
HXDLIN( 368)					gl->vertexAttribPointer(indx2,(int)1,type2,false,(stride * (int)4),::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((int)16));
            				}
            			}
HXLINE( 371)			if (tilemap->tileColorTransformEnabled) {
HXLINE( 373)				int position;
HXDLIN( 373)				if (tilemap->tileAlphaEnabled) {
HXLINE( 373)					position = (int)5;
            				}
            				else {
HXLINE( 373)					position = (int)4;
            				}
HXLINE( 375)				if (hx::IsNotNull( shader->_hx___colorMultiplier )) {
HXLINE( 375)					int indx3 = shader->_hx___colorMultiplier->index;
HXDLIN( 375)					int type3 = gl->FLOAT;
HXDLIN( 375)					gl->vertexAttribPointer(indx3,(int)4,type3,false,(stride * (int)4),::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt((position * (int)4)));
            				}
HXLINE( 376)				if (hx::IsNotNull( shader->_hx___colorOffset )) {
HXLINE( 376)					int indx4 = shader->_hx___colorOffset->index;
HXDLIN( 376)					int type4 = gl->FLOAT;
HXDLIN( 376)					gl->vertexAttribPointer(indx4,(int)4,type4,false,(stride * (int)4),::lime::utils::_DataPointer::DataPointer_Impl__obj::fromInt(((position + (int)4) * (int)4)));
            				}
            			}
HXLINE( 380)			int start;
HXDLIN( 380)			if ((::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition == (int)0)) {
HXLINE( 380)				start = (int)0;
            			}
            			else {
HXLINE( 380)				start = ::Std_obj::_hx_int(((Float)::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition / (Float)stride));
            			}
HXLINE( 381)			int length = ::Std_obj::_hx_int(((Float)(::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition - ::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition) / (Float)stride));
HXLINE( 392)			gl->drawArrays(gl->TRIANGLES,start,length);
HXLINE( 398)			renderer->_hx___clearShader();
            		}
HXLINE( 402)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition = ::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition;
HXLINE( 403)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastUsedBitmapData = ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData;
HXLINE( 404)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastUsedShader = ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,flush,(void))

void GLTilemap_obj::render( ::openfl::display::Tilemap tilemap, ::openfl::display::OpenGLRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_409_render)
HXLINE( 411)		bool _hx_tmp;
HXDLIN( 411)		if (!(!(tilemap->_hx___renderable))) {
HXLINE( 411)			_hx_tmp = (tilemap->_hx___worldAlpha <= (int)0);
            		}
            		else {
HXLINE( 411)			_hx_tmp = true;
            		}
HXDLIN( 411)		if (_hx_tmp) {
HXLINE( 411)			return;
            		}
HXLINE( 413)		::openfl::_internal::renderer::opengl::GLTilemap_obj::buildBuffer(tilemap,renderer);
HXLINE( 415)		if ((tilemap->_hx___bufferLength == (int)0)) {
HXLINE( 415)			return;
            		}
HXLINE( 417)		::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferLength = tilemap->_hx___bufferLength;
HXLINE( 418)		::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition = (int)0;
HXLINE( 420)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastFlushedPosition = (int)0;
HXLINE( 421)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastUsedBitmapData = null();
HXLINE( 422)		::openfl::_internal::renderer::opengl::GLTilemap_obj::lastUsedShader = null();
HXLINE( 423)		::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData = null();
HXLINE( 424)		::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader = null();
HXLINE( 426)		int stride = (int)4;
HXLINE( 427)		if (tilemap->tileAlphaEnabled) {
HXLINE( 427)			stride = (stride + (int)1);
            		}
HXLINE( 428)		if (tilemap->tileColorTransformEnabled) {
HXLINE( 428)			stride = (stride + (int)8);
            		}
HXLINE( 430)		 ::lime::_backend::native::NativeGLRenderContext gl = renderer->_hx___gl;
HXLINE( 432)		renderer->_hx___setBlendMode(tilemap->_hx___worldBlendMode);
HXLINE( 433)		renderer->_hx___pushMaskObject(tilemap,null());
HXLINE( 436)		::openfl::_internal::renderer::opengl::GLTilemap_obj::renderTileContainer(tilemap,renderer,tilemap->_hx___group,tilemap->_hx___worldShader,stride,tilemap->_hx___tileset,tilemap->_hx___worldAlpha,null());
HXLINE( 437)		::openfl::_internal::renderer::opengl::GLTilemap_obj::flush(tilemap,renderer);
HXLINE( 440)		renderer->_hx___popMaskRect();
HXLINE( 441)		renderer->_hx___popMaskObject(tilemap,null());
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,render,(void))

void GLTilemap_obj::renderTileContainer( ::openfl::display::Tilemap tilemap, ::openfl::display::OpenGLRenderer renderer, ::openfl::display::TileContainer group, ::openfl::display::Shader defaultShader,int stride, ::openfl::display::Tileset defaultTileset,Float worldAlpha, ::openfl::display::BitmapData cacheBitmapData){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_446_renderTileContainer)
HXLINE( 448)		::Array< ::Dynamic> tiles = group->_hx___tiles;
HXLINE( 449)		int length = group->__length;
HXLINE( 451)		 ::Dynamic tile;
HXDLIN( 451)		 ::openfl::display::Tileset tileset;
HXDLIN( 451)		Float alpha;
HXDLIN( 451)		bool visible;
HXDLIN( 451)		int id;
HXDLIN( 451)		 ::openfl::display::_Tileset::TileData tileData;
HXDLIN( 451)		 ::openfl::geom::Rectangle tileRect;
HXDLIN( 451)		 ::openfl::display::Shader shader;
HXDLIN( 451)		 ::openfl::display::BitmapData bitmapData;
HXLINE( 452)		 ::Dynamic tileWidth;
HXDLIN( 452)		 ::Dynamic tileHeight;
HXDLIN( 452)		 ::Dynamic uvX;
HXDLIN( 452)		 ::Dynamic uvY;
HXDLIN( 452)		 ::Dynamic uvHeight;
HXDLIN( 452)		 ::Dynamic uvWidth;
HXDLIN( 452)		 ::Dynamic offset;
HXLINE( 454)		{
HXLINE( 454)			int _g = (int)0;
HXDLIN( 454)			while((_g < tiles->length)){
HXLINE( 454)				 ::openfl::display::Tile tile1 = tiles->__get(_g).StaticCast<  ::openfl::display::Tile >();
HXDLIN( 454)				_g = (_g + (int)1);
HXLINE( 456)				if (hx::IsNotNull( tile1->get_tileset() )) {
HXLINE( 456)					tileset = tile1->get_tileset();
            				}
            				else {
HXLINE( 456)					tileset = defaultTileset;
            				}
HXLINE( 458)				alpha = (tile1->get_alpha() * worldAlpha);
HXLINE( 459)				visible = tile1->get_visible();
HXLINE( 460)				bool _hx_tmp;
HXDLIN( 460)				if (!(!(visible))) {
HXLINE( 460)					_hx_tmp = (alpha <= (int)0);
            				}
            				else {
HXLINE( 460)					_hx_tmp = true;
            				}
HXDLIN( 460)				if (_hx_tmp) {
HXLINE( 460)					continue;
            				}
HXLINE( 462)				if (hx::IsNotNull( tile1->get_shader() )) {
HXLINE( 462)					shader = tile1->get_shader();
            				}
            				else {
HXLINE( 462)					shader = defaultShader;
            				}
HXLINE( 464)				if ((tile1->__length > (int)0)) {
HXLINE( 466)					::openfl::_internal::renderer::opengl::GLTilemap_obj::renderTileContainer(tilemap,renderer,( ( ::openfl::display::TileContainer)(tile1) ),shader,stride,tileset,alpha,cacheBitmapData);
            				}
            				else {
HXLINE( 470)					if (hx::IsNull( tileset )) {
HXLINE( 470)						continue;
            					}
HXLINE( 472)					id = tile1->get_id();
HXLINE( 474)					bitmapData = tileset->_hx___bitmapData;
HXLINE( 475)					if (hx::IsNull( bitmapData )) {
HXLINE( 475)						continue;
            					}
HXLINE( 477)					if ((id == (int)-1)) {
HXLINE( 479)						tileRect = tile1->get_rect();
HXLINE( 480)						bool _hx_tmp1;
HXDLIN( 480)						bool _hx_tmp2;
HXDLIN( 480)						if (hx::IsNotNull( tileRect )) {
HXLINE( 480)							_hx_tmp2 = (tileRect->width <= (int)0);
            						}
            						else {
HXLINE( 480)							_hx_tmp2 = true;
            						}
HXDLIN( 480)						if (!(_hx_tmp2)) {
HXLINE( 480)							_hx_tmp1 = (tileRect->height <= (int)0);
            						}
            						else {
HXLINE( 480)							_hx_tmp1 = true;
            						}
HXDLIN( 480)						if (_hx_tmp1) {
HXLINE( 480)							continue;
            						}
            					}
            					else {
HXLINE( 484)						tileData = tileset->_hx___data->__get(id).StaticCast<  ::openfl::display::_Tileset::TileData >();
HXLINE( 485)						if (hx::IsNull( tileData )) {
HXLINE( 485)							continue;
            						}
            					}
HXLINE( 489)					bool _hx_tmp3;
HXDLIN( 489)					bool _hx_tmp4;
HXDLIN( 489)					if (hx::IsNotEq( shader,::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader )) {
HXLINE( 489)						_hx_tmp4 = hx::IsNotNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader );
            					}
            					else {
HXLINE( 489)						_hx_tmp4 = false;
            					}
HXDLIN( 489)					if (!(_hx_tmp4)) {
HXLINE( 489)						if (hx::IsNotEq( bitmapData,::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData )) {
HXLINE( 489)							_hx_tmp3 = hx::IsNotNull( ::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData );
            						}
            						else {
HXLINE( 489)							_hx_tmp3 = false;
            						}
            					}
            					else {
HXLINE( 489)						_hx_tmp3 = true;
            					}
HXDLIN( 489)					if (_hx_tmp3) {
HXLINE( 491)						::openfl::_internal::renderer::opengl::GLTilemap_obj::flush(tilemap,renderer);
            					}
HXLINE( 495)					::openfl::_internal::renderer::opengl::GLTilemap_obj::currentBitmapData = bitmapData;
HXLINE( 496)					::openfl::_internal::renderer::opengl::GLTilemap_obj::currentShader = shader;
HXLINE( 497)					 ::Dynamic _hx_tmp5 = hx::ClassOf< ::openfl::_internal::renderer::opengl::GLTilemap >();
HXDLIN( 497)					::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition = (::openfl::_internal::renderer::opengl::GLTilemap_obj::bufferPosition + (stride * (int)6));
            				}
            			}
            		}
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC8(GLTilemap_obj,renderTileContainer,(void))

void GLTilemap_obj::renderMask( ::openfl::display::Tilemap tilemap, ::openfl::display::OpenGLRenderer renderer){
            	HX_STACKFRAME(&_hx_pos_40a075b64d21c9aa_506_renderMask)
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,renderMask,(void))

void GLTilemap_obj::resizeBuffer( ::openfl::display::Tilemap tilemap,int length){
            	HX_GC_STACKFRAME(&_hx_pos_40a075b64d21c9aa_592_resizeBuffer)
HXLINE( 594)		if (hx::IsNull( tilemap->_hx___bufferData )) {
HXLINE( 596)			 ::lime::utils::ArrayBufferView this1;
HXDLIN( 596)			if (hx::IsNotNull( length )) {
HXLINE( 596)				this1 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,length,(int)8);
            			}
            			else {
HXLINE( 596)				HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            			}
HXDLIN( 596)			tilemap->_hx___bufferData = this1;
            		}
            		else {
HXLINE( 598)			if ((length > tilemap->_hx___bufferData->length)) {
HXLINE( 600)				 ::lime::utils::ArrayBufferView this2;
HXDLIN( 600)				if (hx::IsNotNull( length )) {
HXLINE( 600)					this2 =  ::lime::utils::ArrayBufferView_obj::__alloc( HX_CTX ,length,(int)8);
            				}
            				else {
HXLINE( 600)					HX_STACK_DO_THROW(HX_("Invalid constructor arguments for Float32Array",8e,c1,f4,d4));
            				}
HXDLIN( 600)				 ::lime::utils::ArrayBufferView buffer = this2;
HXLINE( 601)				{
HXLINE( 601)					 ::lime::utils::ArrayBufferView view = tilemap->_hx___bufferData;
HXDLIN( 601)					int offset = (int)0;
HXDLIN( 601)					if (hx::IsNotNull( view )) {
HXLINE( 601)						 ::haxe::io::Bytes buffer1 = buffer->buffer;
HXDLIN( 601)						buffer1->blit((offset * buffer->bytesPerElement),view->buffer,view->byteOffset,view->byteLength);
            					}
            					else {
HXLINE( 601)						HX_STACK_DO_THROW(HX_("Invalid .set call. either view, or array must be not-null.",64,ba,b7,6c));
            					}
            				}
HXLINE( 602)				tilemap->_hx___bufferData = buffer;
            			}
            		}
HXLINE( 606)		tilemap->_hx___bufferLength = length;
            	}


STATIC_HX_DEFINE_DYNAMIC_FUNC2(GLTilemap_obj,resizeBuffer,(void))


GLTilemap_obj::GLTilemap_obj()
{
}

bool GLTilemap_obj::__GetStatic(const ::String &inName, Dynamic &outValue, hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 5:
		if (HX_FIELD_EQ(inName,"flush") ) { outValue = flush_dyn(); return true; }
		break;
	case 6:
		if (HX_FIELD_EQ(inName,"render") ) { outValue = render_dyn(); return true; }
		break;
	case 10:
		if (HX_FIELD_EQ(inName,"renderMask") ) { outValue = renderMask_dyn(); return true; }
		break;
	case 11:
		if (HX_FIELD_EQ(inName,"buildBuffer") ) { outValue = buildBuffer_dyn(); return true; }
		break;
	case 12:
		if (HX_FIELD_EQ(inName,"bufferLength") ) { outValue = ( bufferLength ); return true; }
		if (HX_FIELD_EQ(inName,"resizeBuffer") ) { outValue = resizeBuffer_dyn(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentShader") ) { outValue = ( currentShader ); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"bufferPosition") ) { outValue = ( bufferPosition ); return true; }
		if (HX_FIELD_EQ(inName,"lastUsedShader") ) { outValue = ( lastUsedShader ); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"currentBitmapData") ) { outValue = ( currentBitmapData ); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"lastUsedBitmapData") ) { outValue = ( lastUsedBitmapData ); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"cacheColorTransform") ) { outValue = ( cacheColorTransform ); return true; }
		if (HX_FIELD_EQ(inName,"lastFlushedPosition") ) { outValue = ( lastFlushedPosition ); return true; }
		if (HX_FIELD_EQ(inName,"renderTileContainer") ) { outValue = renderTileContainer_dyn(); return true; }
		break;
	case 24:
		if (HX_FIELD_EQ(inName,"buildBufferTileContainer") ) { outValue = buildBufferTileContainer_dyn(); return true; }
	}
	return false;
}

bool GLTilemap_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 12:
		if (HX_FIELD_EQ(inName,"bufferLength") ) { bufferLength=ioValue.Cast< int >(); return true; }
		break;
	case 13:
		if (HX_FIELD_EQ(inName,"currentShader") ) { currentShader=ioValue.Cast<  ::openfl::display::Shader >(); return true; }
		break;
	case 14:
		if (HX_FIELD_EQ(inName,"bufferPosition") ) { bufferPosition=ioValue.Cast< int >(); return true; }
		if (HX_FIELD_EQ(inName,"lastUsedShader") ) { lastUsedShader=ioValue.Cast<  ::openfl::display::Shader >(); return true; }
		break;
	case 17:
		if (HX_FIELD_EQ(inName,"currentBitmapData") ) { currentBitmapData=ioValue.Cast<  ::openfl::display::BitmapData >(); return true; }
		break;
	case 18:
		if (HX_FIELD_EQ(inName,"lastUsedBitmapData") ) { lastUsedBitmapData=ioValue.Cast<  ::openfl::display::BitmapData >(); return true; }
		break;
	case 19:
		if (HX_FIELD_EQ(inName,"cacheColorTransform") ) { cacheColorTransform=ioValue.Cast<  ::openfl::geom::ColorTransform >(); return true; }
		if (HX_FIELD_EQ(inName,"lastFlushedPosition") ) { lastFlushedPosition=ioValue.Cast< int >(); return true; }
	}
	return false;
}

#if HXCPP_SCRIPTABLE
static hx::StorageInfo *GLTilemap_obj_sMemberStorageInfo = 0;
static hx::StaticInfo GLTilemap_obj_sStaticStorageInfo[] = {
	{hx::fsInt,(void *) &GLTilemap_obj::bufferLength,HX_HCSTRING("bufferLength","\x06","\x86","\xdc","\xa3")},
	{hx::fsInt,(void *) &GLTilemap_obj::bufferPosition,HX_HCSTRING("bufferPosition","\xc9","\x19","\xc6","\x63")},
	{hx::fsObject /*::openfl::geom::ColorTransform*/ ,(void *) &GLTilemap_obj::cacheColorTransform,HX_HCSTRING("cacheColorTransform","\x6b","\xb5","\xa2","\x9a")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(void *) &GLTilemap_obj::currentBitmapData,HX_HCSTRING("currentBitmapData","\x52","\x37","\xf6","\x0a")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(void *) &GLTilemap_obj::currentShader,HX_HCSTRING("currentShader","\x3e","\x40","\x7d","\x00")},
	{hx::fsInt,(void *) &GLTilemap_obj::lastFlushedPosition,HX_HCSTRING("lastFlushedPosition","\x36","\xba","\x56","\xb9")},
	{hx::fsObject /*::openfl::display::BitmapData*/ ,(void *) &GLTilemap_obj::lastUsedBitmapData,HX_HCSTRING("lastUsedBitmapData","\x4c","\x23","\x11","\xc8")},
	{hx::fsObject /*::openfl::display::Shader*/ ,(void *) &GLTilemap_obj::lastUsedShader,HX_HCSTRING("lastUsedShader","\x38","\x27","\x00","\x39")},
	{ hx::fsUnknown, 0, null()}
};
#endif

static void GLTilemap_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::bufferLength,"bufferLength");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::bufferPosition,"bufferPosition");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::cacheColorTransform,"cacheColorTransform");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::currentBitmapData,"currentBitmapData");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::currentShader,"currentShader");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::lastFlushedPosition,"lastFlushedPosition");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::lastUsedBitmapData,"lastUsedBitmapData");
	HX_MARK_MEMBER_NAME(GLTilemap_obj::lastUsedShader,"lastUsedShader");
};

#ifdef HXCPP_VISIT_ALLOCS
static void GLTilemap_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::__mClass,"__mClass");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::bufferLength,"bufferLength");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::bufferPosition,"bufferPosition");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::cacheColorTransform,"cacheColorTransform");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::currentBitmapData,"currentBitmapData");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::currentShader,"currentShader");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::lastFlushedPosition,"lastFlushedPosition");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::lastUsedBitmapData,"lastUsedBitmapData");
	HX_VISIT_MEMBER_NAME(GLTilemap_obj::lastUsedShader,"lastUsedShader");
};

#endif

hx::Class GLTilemap_obj::__mClass;

static ::String GLTilemap_obj_sStaticFields[] = {
	HX_HCSTRING("bufferLength","\x06","\x86","\xdc","\xa3"),
	HX_HCSTRING("bufferPosition","\xc9","\x19","\xc6","\x63"),
	HX_HCSTRING("cacheColorTransform","\x6b","\xb5","\xa2","\x9a"),
	HX_HCSTRING("currentBitmapData","\x52","\x37","\xf6","\x0a"),
	HX_HCSTRING("currentShader","\x3e","\x40","\x7d","\x00"),
	HX_HCSTRING("lastFlushedPosition","\x36","\xba","\x56","\xb9"),
	HX_HCSTRING("lastUsedBitmapData","\x4c","\x23","\x11","\xc8"),
	HX_HCSTRING("lastUsedShader","\x38","\x27","\x00","\x39"),
	HX_HCSTRING("buildBuffer","\xce","\xa2","\x05","\x21"),
	HX_HCSTRING("buildBufferTileContainer","\x85","\x38","\x40","\xad"),
	HX_HCSTRING("flush","\xc4","\x62","\x9b","\x02"),
	HX_HCSTRING("render","\x56","\x6b","\x29","\x05"),
	HX_HCSTRING("renderTileContainer","\xfd","\xba","\x73","\x84"),
	HX_HCSTRING("renderMask","\x62","\x3b","\x60","\xe5"),
	HX_HCSTRING("resizeBuffer","\x14","\x7a","\xa2","\xb4"),
	::String(null())
};

void GLTilemap_obj::__register()
{
	hx::Object *dummy = new GLTilemap_obj;
	GLTilemap_obj::_hx_vtable = *(void **)dummy;
	hx::Static(__mClass) = new hx::Class_obj();
	__mClass->mName = HX_HCSTRING("openfl._internal.renderer.opengl.GLTilemap","\x25","\xe7","\x07","\x88");
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &GLTilemap_obj::__GetStatic;
	__mClass->mSetStaticField = &GLTilemap_obj::__SetStatic;
	__mClass->mMarkFunc = GLTilemap_obj_sMarkStatics;
	__mClass->mStatics = hx::Class_obj::dupFunctions(GLTilemap_obj_sStaticFields);
	__mClass->mMembers = hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = hx::TCanCast< GLTilemap_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = GLTilemap_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = GLTilemap_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = GLTilemap_obj_sStaticStorageInfo;
#endif
	hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

} // end namespace openfl
} // end namespace _internal
} // end namespace renderer
} // end namespace opengl
